# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

AsyncSocketSender.create.thread=Create sender [{0}:{1,number,integer}] queue thread to tcp background replication
AsyncSocketSender.queue.message=Queue message to [{0}:{1,number,integer}] id=[{2}] size={3}
AsyncSocketSender.send.error=Unable to asynchronously send session with id=[{0}] - message will be ignored.
AsyncSocketSender.queue.empty=Queue in sender [{0}:{1,number,integer}] returned null element!
cluster.mbean.register.already=MBean {0} already registered!
FastAsyncSocketSender.setThreadPriority=[{0}:{1,number,integer}] set priority to {2}
FastAsyncSocketSender.min.exception=[{0}:{1,number,integer}] new priority {2} < MIN_PRIORITY
FastAsyncSocketSender.max.exception=[{0}:{1,number,integer}] new priority {2} > MAX_PRIORITY
IDataSender.ack.eof=EOF reached at local port [{0}:{1,number,integer}]
IDataSender.ack.receive=Got ACK at local port [{0}:{1,number,integer}]
IDataSender.ack.missing=Unable to read acknowledgement from [{0}:{1,number,integer}] in {2,number,integer} ms. Disconnecting socket, and trying again.
IDataSender.ack.read=Read wait ack char '{2}' [{0}:{1,number,integer}]
IDataSender.ack.start=Waiting for ACK message [{0}:{1,number,integer}]
IDataSender.ack.wrong=Missing correct ACK after 10 bytes read at local port [{0}:{1,number,integer}]
IDataSender.closeSocket=Sender close socket to [{0}:{1,number,integer}] (close count {2,number,integer})
IDataSender.connect=Sender connect to [{0}:{1,number,integer}] (connect count {2,number,integer})
IDataSender.create=Create sender [{0}:{1,number,integer}]
IDataSender.disconnect=Sender disconnect from [{0}:{1,number,integer}] (disconnect count {2,number,integer})
IDataSender.message.disconnect=Message transfered: Sender can't disconnect from [{0}:{1,number,integer}]
IDataSender.message.create=Message transfered: Sender can't create current socket [{0}:{1,number,integer}]
IDataSender.openSocket=Sender open socket to [{0}:{1,number,integer}] (open count {2,number,integer})
IDataSender.openSocket.failure=Open sender socket [{0}:{1,number,integer}] failure! (open failure count {2,number,integer})
IDataSender.send.again=Send data again to [{0}:{1,number,integer}]
IDataSender.send.crash=Send message crashed [{0}:{1,number,integer}] type=[{2}], id=[{3}]
IDataSender.send.message=Send message to [{0}:{1,number,integer}] id=[{2}] size={3,number,integer}
IDataSender.send.lost=Message lost: [{0}:{1,number,integer}] type=[{2}], id=[{3}]
IDataSender.senderModes.Configured=Configured a data replication sender for mode {0}
IDataSender.senderModes.Instantiate=Can't instantiate a data replication sender of class {0}
IDataSender.senderModes.Missing=Can't configure a data replication sender for mode {0}
IDataSender.senderModes.Resources=Can't load data replication sender mapping list
IDataSender.stats=Send stats from [{0}:{1,number,integer}], Nr of bytes sent={2,number,integer} over {3} = {4,number,integer} bytes/request, processing time {5,number,integer} msec, avg processing time {6,number,integer} msec
PoolSocketSender.senderQueue.sender.failed=PoolSocketSender create new sender to [{0}:{1,number,integer}] failed
PoolSocketSender.noMoreSender=No socket sender available for client [{0}:{1,number,integer}] did it disappeared?
ReplicationTransmitter.getProperty=get property {0}
ReplicationTransmitter.setProperty=set property {0}: {1} old value {2}
ReplicationTransmitter.started=Start ClusterSender at cluster {0} with name {1}
ReplicationTransmitter.stopped=Stopped ClusterSender at cluster {0} with name {1}
ReplicationValve.crossContext.add=add Cross Context session replication container to replicationValve threadlocal
ReplicationValve.crossContext.registerSession=register Cross context session id={0} from context {1}
ReplicationValve.crossContext.remove=remove Cross Context session replication container from replicationValve threadlocal
ReplicationValve.crossContext.sendDelta=send Cross Context session delta from context {0}.
ReplicationValve.filter.loading=Loading request filters={0}
ReplicationValve.filter.token=Request filter={0}
ReplicationValve.filter.token.failure=Unable to compile filter={0}
ReplicationValve.invoke.uri=Invoking replication request on {0}
ReplicationValve.nocluster=No cluster configured for this request.
ReplicationValve.resetDeltaRequest=Cluster is standalone: reset Session Request Delta at context {0}
ReplicationValve.send.failure=Unable to perform replication request.
ReplicationValve.send.invalid.failure=Unable to send session [id={0}] invalid message over cluster.
ReplicationValve.session.found=Context {0}: Found session {1} but it isn't a ClusterSession.
ReplicationValve.session.indicator=Context {0}: Primarity of session {0} in request attribute {1} is {2}.
ReplicationValve.session.invalid=Context {0}: Requested session {1} is invalid, removed or not replicated at this node.
ReplicationValve.stats=Average request time= {0} ms for Cluster overhead time={1} ms for {2} requests {3} filter requests {4} send requests {5} cross context requests (Request={6} ms Cluster={7} ms).
SimpleTcpCluster.event.log=Cluster receive listener event {0} with data {1}
SimpleTcpCluster.getProperty=get property {0}
SimpleTcpCluster.setProperty=set property {0}: {1} old value {2}
SimpleTcpCluster.default.addClusterListener=Add Default ClusterListener at cluster {0}
SimpleTcpCluster.default.addClusterValves=Add Default ClusterValves at cluster {0}
SimpleTcpCluster.default.addClusterReceiver=Add Default ClusterReceiver at cluster {0}
SimpleTcpCluster.default.addClusterSender=Add Default ClusterSender at cluster {0}
SimpleTcpCluster.default.addMembershipService=Add Default Membership Service at cluster {0}
SimpleTcpCluster.log.receive=RECEIVE {0,date}:{0,time} {1,number} {2}:{3,number,integer} {4} {5}
SimpleTcpCluster.log.send=SEND {0,date}:{0,time} {1,number} {2}:{3,number,integer} {4} 
SimpleTcpCluster.log.send.all=SEND {0,date}:{0,time} {1,number} - {2}
