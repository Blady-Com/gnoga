# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

AsyncSocketSender.create.thread = Crear remitente [{0}\:{1,number,integer}] hilo en cola a r\u00E9plica de tcp en segundo plano
AsyncSocketSender.queue.message = Poner en cola mensaje para [{0}\:{1,number,integer}] id\=[{2}] medida\={3}
AsyncSocketSender.send.error = No puedo enviar sesi\u00F3n de forma as\u00EDncrona con id\=[{0}] - se ignora el mensaje.
AsyncSocketSender.queue.empty = \u00A1La cola en remitente [{0}\:{1,number,integer}] devolvi\u00F3 elemento nulo\!
cluster.mbean.register.already = \u00A1MBean {0} ya registrado\!
IDataSender.ack.eof = EOF alcanzado en puerto local [{0}\:{1,number,integer}]
IDataSender.ack.receive = Obtenido ACK en puerto local [{0}\:{1,number,integer}]
IDataSender.ack.missing = No puedo leer reconocimiento desde [{0}\:{1,number,integer}] en {2,number,integer} ms. Desconectando conector e intentando otra vez.
IDataSender.ack.read = Car\u00E1cter de espera de lectura ack '{2}' [{0}\:{1,number,integer}]
IDataSender.ack.start = Esperando por mensaje ACK [{0}\:{1,number,integer}]
IDataSender.ack.wrong = Falta ACK correcto tras 10 bytes le\u00EDdos en puerto local [{0}\:{1,number,integer}]
IDataSender.closeSocket = El remitente cerr\u00F3 el conector con [{0}\:{1,number,integer}] (contador de cierre {2,number,integer})
IDataSender.connect = Remitente conectado con [{0}\:{1,number,integer}] (contador de conexi\u00F3n {2,number,integer})
IDataSender.create = Crear remitente [{0}\:{1,number,integer}]
IDataSender.disconnect = Remitente desconectado de [{0}\:{1,number,integer}] (contador de desconexi\u00F3n {2,number,integer})
IDataSender.message.disconnect = Mensaje transferido\: El remitente no se pude desconectar de [{0}\:{1,number,integer}]
IDataSender.message.create = Mensaje transferido\: El remitente no puede crear conector en curso [{0}\:{1,number,integer}]
IDataSender.openSocket = Remitente abri\u00F3 conector con [{0}\:{1,number,integer}] (contador de apertura {2,number,integer})
IDataSender.openSocket.failure = \u00A1No pude abrir conector de remitente [{0}\:{1,number,integer}]\! (contador de fallo de apertura {2,number,integer})
IDataSender.send.again = Enviar datos de nuevo a [{0}\:{1,number,integer}]
IDataSender.send.crash = Enviar mensaje se rompi\u00F3 [{0}\:{1,number,integer}] tipo\=[{2}], id\=[{3}]
IDataSender.send.message = Enviar mensaje a [{0}\:{1,number,integer}] id\=[{2}] medida\={3,number,integer}
IDataSender.send.lost = Mensaje perdido\: [{0}\:{1,number,integer}] tipo\=[{2}], id\=[{3}]
IDataSender.senderModes.Configured = Configurado un remitente de r\u00E9plica de datos para el modo {0}
IDataSender.senderModes.Instantiate = No puedo instanciar remitente de r\u00E9plica de datos de clase {0}
IDataSender.senderModes.Missing = No puedo configurar remitente de r\u00E9plica de datos para modo {0}
IDataSender.senderModes.Resources = No puedo cargar lista de mapeo de remitente de r\u00E9plica de datos de clase {0}
IDataSender.stats = Estados de Env\u00EDo desde [{0}\:{1,number,integer}], Nr de bytes enviado\={2,number,integer} sobre {3} \= {4,number,integer} bytes/requerimiento, tiempo de proceso {5,number,integer} mseg, tiempo medio de proceso {6,number,integer} mseg
PoolSocketSender.senderQueue.sender.failed = PoolSocketSender fall\u00F3 el crear nuevo remitente para [{0}\:{1,number,integer}]
PoolSocketSender.noMoreSender = No hay disponible remitente de conector para cliente [{0}\:{1,number,integer}] \u00BFha desaparecido?
ReplicationTransmitter.getProperty = obtener propiedad {0}
ReplicationTransmitter.setProperty = poner propiedad {0}\: {1} valor viejo {2}
ReplicationTransmitter.started = Iniciar ClusterSender en cl\u00FAster {0} con nombre {1}
ReplicationTransmitter.stopped = Parado ClusterSender en cl\u00FAster {0} con nombre {1}
ReplicationValve.crossContext.add = a\u00F1adir contenedor de r\u00E9plica de sesi\u00F3n de Contexto Cruzado con hilo local de replicationValve
ReplicationValve.crossContext.registerSession = registrado sesi\u00F3n de contexto Cruzado con id\={0} desde contexto {1}
ReplicationValve.crossContext.remove = quitar contenedor de r\u00E9plica de sesi\u00F3n de Contexto Cruzado con hilo local de replicationValve
ReplicationValve.crossContext.sendDelta = enviar sesi\u00F3n delta de Contexto Cruzado desde contexto {0}.
ReplicationValve.filter.loading = Cargando filtros de requerimiento\={0}
ReplicationValve.filter.token = Filtro de requerimiento\={0}
ReplicationValve.filter.token.failure = No puedo compilar filtro\={0}
ReplicationValve.invoke.uri = Invocando requerimiento de r\u00E9plica en {0}
ReplicationValve.nocluster = No hay cl\u00FAster configurado para este requerimiento.
ReplicationValve.resetDeltaRequest = El Cl\u00FAster es aut\u00F3nomo\: limpiado Delta de Requerimiento de Sesi\u00F3n en contexto {0}
ReplicationValve.send.failure = No puedo realizar requerimiento de r\u00E9plica.
ReplicationValve.send.invalid.failure = El Cl\u00FAster es aut\u00F3nomo\: limpiado Delta de Requerimiento de Sesi\u00F3n en contexto {0}
ReplicationValve.session.found = Contexto {0}\: Hallada sesi\u00F3n {1} pero no es una ClusterSession.
ReplicationValve.session.indicator = Contexto {0}\: La primac\u00EDa de la sesi\u00F3n {0} en atributo de requerimiento {1} es {2}.
ReplicationValve.session.invalid = Contexto {0}\: La sesi\u00F3n requerida {1} es inv\u00E1lida, quitada o no replicada en este nodo.
ReplicationValve.stats = Tiempo de requerimiento medio\= {0} ms para tiempo de sobrecarga de Cl\u00FAster\={1} ms para {2} requerimientos {3} requerimientos de filtro {4} requerimientos de env\u00EDo {5} requerimientos de contexto cruzado (Requerimiento\={6} ms Cl\u00FAster\={7} ms).
SimpleTcpCluster.event.log = Cl\u00FAster recibi\u00F3 evento de oyente {0} con datos {1}
SimpleTcpCluster.getProperty = obtener propiedad {0}
SimpleTcpCluster.setProperty = poner propiedad {0}\: {1} valor viejo {2}
SimpleTcpCluster.default.addClusterListener = A\u00F1adir ClusterListener por defecto en cl\u00FAster {0}
SimpleTcpCluster.default.addClusterValves = A\u00F1adir ClusterValves por defecto en cl\u00FAster {0}
SimpleTcpCluster.default.addClusterReceiver = A\u00F1adir ClusterReceiver por defecto en cl\u00FAster {0}
SimpleTcpCluster.default.addClusterSender = A\u00F1adir ClusterSender por defecto en cl\u00FAster {0}
SimpleTcpCluster.default.addMembershipService = A\u00F1adir Servicio de Miembro por defecto en cl\u00FAster {0}
SimpleTcpCluster.log.receive = RECIBIDO {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4} {5}
SimpleTcpCluster.log.send = ENVIADO {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4} 
SimpleTcpCluster.log.send.all = ENVIADO {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4} 
