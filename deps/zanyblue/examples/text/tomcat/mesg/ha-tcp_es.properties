# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

AsyncSocketSender.create.thread = Crear remitente [{0}\:{1,number,integer}] poner hilo en cola a r\u00E9plica tcp en segundo plano
AsyncSocketSender.queue.message = Poner mensaje en cola para [{0}\:{1,number,integer}] id\=[{2}] medida\={3}
AsyncSocketSender.send.error = No puedo enviar de forma as\u00EDncrona sesi\u00F3n con id\=[{0}] - el mensaje ser\u00E1 ignorado.
AsyncSocketSender.queue.empty = Poner en cola en remitente [{0}\:{1,number,integer}] \u00A1devolvi\u00F3 elemento nulo\!
cluster.mbean.register.already = \u00A1MBean {0} ya registrado\!
FastAsyncSocketSender.setThreadPriority = [{0}\:{1,number,integer}] puesta prioridad a {2}
FastAsyncSocketSender.min.exception = [{0}\:{1,number,integer}]}] nueva prioridad {2} < MIN_PRIORITY
FastAsyncSocketSender.max.exception = [{0}\:{1,number,integer}]}] nueva prioridad {2} > MAX_PRIORITY
IDataSender.ack.eof = EOF alcanzado en puerto local [{0}\:{1,number,integer}]
IDataSender.ack.receive = Obtenido un ACK en puerto local [{0}\:{1,number,integer}]
IDataSender.ack.missing = No puedo leer reconocimiento desde [{0}\:{1,number,integer}] en {2,number,integer} ms. Desconectadno conector y probando otra vez.
IDataSender.ack.read = Le\u00EDdo car\u00E1cter ack de espera '{2}' [{0}\:{1,number,integer}]
IDataSender.ack.start = Eperando por mensaje ACK [{0}\:{1,number,integer}]
IDataSender.ack.wrong = Falta ACK correcto tras leer 10 bytes en puerto local [{0}\:{1,number,integer}]
IDataSender.closeSocket = El remitente cerr\u00F3 conector a [{0}\:{1,number,integer}] (contador de cierre {2,number,integer})
IDataSender.connect = El remitente se conect\u00F3 a [{0}\:{1,number,integer}] (contador de conexi\u00F3n {2,number,integer})
IDataSender.create = Crear remitente [{0}\:{1,number,integer}]
IDataSender.disconnect = El remitente se desconect\u00F3 de [{0}\:{1,number,integer}] (contador de desconexi\u00F3n {2,number,integer})
IDataSender.message.disconnect = Mensaje transferido\: El remitente no se puede desconectar de [{0}\:{1,number,integer}]
IDataSender.message.create = Mensaje transferido\: El remitente no puede crear conector actual [{0}\:{1,number,integer}]
IDataSender.openSocket = El remitente abri\u00F3 conector con [{0}\:{1,number,integer}] (contador de apertura {2,number,integer})
IDataSender.openSocket.failure = \u00A1Fallo al abrir conector de remitente [{0}\:{1,number,integer}]\! (contador de fallos de apertura {2,number,integer})
IDataSender.send.again = Enviar datos de nuevo a [{0}\:{1,number,integer}]
IDataSender.send.crash = Enviar mensaje destrozado [{0}\:{1,number,integer}] tipo\=[{2}], id\=[{3}]
IDataSender.send.message = Enviar mensaje a [{0}\:{1,number,integer}] id\=[{2}] medida\={3,number,integer}
IDataSender.send.lost = Mensaje perdido\: [{0}\:{1,number,integer}] tipo\=[{2}], id\=[{3}]
IDataSender.senderModes.Configured = Configurado un remitente de r\u00E9plica de datos para modo {0}
IDataSender.senderModes.Instantiate = No puedo instanciar un remitente de r\u00E9plica de datos de clase {0}
IDataSender.senderModes.Missing = No puedo configurar un remitente de r\u00E9plica de datos para modo {0}
IDataSender.senderModes.Resources = No puedo cargar lista de mapeo de remitente de r\u00E9plica de datos
IDataSender.stats = Estado de env\u00EDo desde [{0}\:{1,number,integer}], Nr de bytes enviado\={2,number,integer} sobre {3} \= {4,number,integer} bytes/requerimiento, tiempo de proceso {5,number,integer} mseg, tiempo medio de proceso {6,number,integer} mseg
PoolSocketSender.senderQueue.sender.failed = PoolSocketSender fall\u00F3 el crear nuevo remitente para [{0}\:{1,number,integer}]
PoolSocketSender.noMoreSender = No hay remitente de conector disponible para cliente [{0}\:{1,number,integer}] \u00BFdesapareci\u00F3?
ReplicationTransmitter.getProperty = obtener propiedad {0}
ReplicationTransmitter.setProperty = poner propiedad {0}\: {1} viejo valor {2}
ReplicationTransmitter.started = Iniciar ClusterSender en cl\u00FAster {0} con nombre {1}
ReplicationTransmitter.stopped = Parado ClusterSender en cl\u00FAster {0} con nombre {1}
ReplicationValve.crossContext.add = a\u00F1adir contenedor de r\u00E9plica de sesi\u00F3n de Contexto Cruzado a replicationValve threadlocal
ReplicationValve.crossContext.registerSession = retistrar id de sesi\u00F3n de Contexto Cruzado\={0} desde contexto {1}
ReplicationValve.crossContext.remove = quitar contenedor de r\u00E9plica de sesi\u00F3n de Contexto Cruzado a replicationValve threadlocal
ReplicationValve.crossContext.sendDelta = enviar delta de sesi\u00F3n de Contexto Cruzado desde contexto {0}.
ReplicationValve.filter.loading = Cargando filtros de requerimiento\={0}
ReplicationValve.filter.token = Filtro de requerimiento\={0}
ReplicationValve.filter.token.failure = No puedo compilar filtror\={0}
ReplicationValve.invoke.uri = Invocando requerimiento de r\u00E9plica en {0}
ReplicationValve.nocluster = No cluster configured for this request.
ReplicationValve.resetDeltaRequest = Cluster is standalone\: reset Session Request Delta at context {0}
ReplicationValve.send.failure = Unable to perform replication request.
ReplicationValve.send.invalid.failure = Unable to send session [id\={0}] invalid message over cluster.
ReplicationValve.session.found = Context {0}\: Found session {1} but it isn't a ClusterSession.
ReplicationValve.session.indicator = Context {0}\: Primarity of session {0} in request attribute {1} is {2}.
ReplicationValve.session.invalid = Context {0}\: Requested session {1} is invalid, removed or not replicated at this node.
ReplicationValve.stats = Average request time\= {0} ms for Cluster overhead time\={1} ms for {2} requests {3} filter requests {4} send requests {5} cross context requests (Request\={6} ms Cluster\={7} ms).
SimpleTcpCluster.event.log = Cluster receive listener event {0} with data {1}
SimpleTcpCluster.getProperty = get property {0}
SimpleTcpCluster.setProperty = set property {0}\: {1} old value {2}
SimpleTcpCluster.default.addClusterListener = Add Default ClusterListener at cluster {0}
SimpleTcpCluster.default.addClusterValves = Add Default ClusterValves at cluster {0}
SimpleTcpCluster.default.addClusterReceiver = Add Default ClusterReceiver at cluster {0}
SimpleTcpCluster.default.addClusterSender = Add Default ClusterSender at cluster {0}
SimpleTcpCluster.default.addMembershipService = Add Default Membership Service at cluster {0}
SimpleTcpCluster.log.receive = RECEIVE {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4} {5}
SimpleTcpCluster.log.send = SEND {0,date}\:{0,time} {1,number} {2}\:{3,number,integer} {4} 
SimpleTcpCluster.log.send.all = SEND {0,date}\:{0,time} {1,number} - {2}
